## Код для исследования:
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}

### ClassLoaders
1. **Bootstrap ClassLoader** загружает основные классы Java
2. **PLatform ClassLoader** загружает классы из стандартных расширений
3. **Application ClassLoader** загружает пользовательские классы, включая класс JvmComprehension
   
Когда программа запускается, Application ClassLoader загружает JvmComprehension.class в **MetaSpace**, также в Metaspace хранятся другие системные классы

### Области памяти
Сначала JVM создает фрейм в Stack для метода main()

* Строка №1: переменная **i** создается в стеке во фрейме main(), так как это примитив, переменная и ее значения хранятся прямо в стеке
* Строка №2: происходит сразу три операции: сначала с помощью **new** выделяется память в куче, затем происходит вызов конструктора **()**, после чего происходит операция присваивания **=**. Результат: объект Object создается в куче, а ссылка на объект хранится в стеке в переменной **о**
* Строка №3: 2 попадает в диапазон кэша Integer, поэтому JVM не создаст новый объект, а возьмет его из пула Integer, ссылка на объект хранится в стеке в переменной **ii**
* Строка №4: создается новый фрейм в стеке для метода printAll(), локальные переменные o, i, ii передаются в новый фрейм следующим образом: 
  * int i передается по значению и просто копируется в новый фрейм
  * для o и ii создаются новые переменные, но они хранят те же ссылки на объекты в куче, то есть происходит передача по ссылке
* Строка №5: создается новый объект Integer в куче, а ссылка на него, uselessVar, хранится в стеке во фрейме метода printAll()
* Строка №6: сначала в куче создается объект String в результате выполнения метода toString(), затем создается новый объект String в результате первой конкатенации, после чего создается третий объект String в результате второй конкатенации. В стеке создается новый фрейм для метода println, куда будет передана ссылка на третий объект String, который получился после всех конкатенаций.
* Строка 7: JVM создаст новый фрейм для метода println(), а строка "finished" будет взята из String Pool, поэтому новый объект в куче не создается.

### Garbage Collector
Что будет удалено:
* После выхода из метода printAll() будет удален объект uselessVar, а также временные строки, которые получались во время конкатенации. Эти объекты удалятся быстрее всех.
* объект o будет удален после выхода из метода Main()

Что не будет удалено:
* "finished" в String Pool
* Integer ii = 2 (попадает в Integer Cache).


